<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Happy Flip Chess vs AI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #game-container {
            position: relative;
        }
        .piece {
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .red-piece {
            color: #c0392b;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        .blue-piece {
            color: #2980b9;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        .valid-move::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: rgba(46, 204, 113, 0.7);
            border-radius: 50%;
        }
    </style>
</head>
<body class="bg-[#312e2b] text-[#ecf0f1] flex justify-center items-center min-h-screen p-4">
<div id="game-container" class="flex flex-col items-center text-center">
    <h1 class="text-2xl md:text-4xl font-bold mb-4 text-white" style="text-shadow: 2px 2px 4px #000;">Happy Flip Chess</h1>
    
    <div id="chess-board" class="grid grid-cols-8 grid-rows-4 bg-[#f0d9b5] border-4 border-[#6f4f28] gap-1 p-2 relative shadow-2xl">
        <!-- Squares will be generated by JavaScript -->
    </div>

    <!-- Overlays -->
    <div id="pregame-overlay" class="absolute inset-0 bg-black bg-opacity-70 flex items-center justify-center flex-col z-20">
        <h2 class="text-4xl font-bold text-white mb-8">Who will play first?</h2>
        <div class="flex gap-8">
            <button id="human-first-btn" class="px-8 py-4 text-2xl bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-lg">Human First</button>
            <button id="ai-first-btn" class="px-8 py-4 text-2xl bg-red-600 hover:bg-red-700 text-white font-bold rounded-lg">AI First</button>
        </div>
    </div>
    <div id="winner-overlay" class="absolute inset-0 bg-black bg-opacity-60 hidden items-center justify-center flex-col z-10 cursor-pointer">
        <h2 id="winner-text" class="text-4xl md:text-6xl font-bold text-center" style="text-shadow: 3px 3px 8px rgba(0,0,0,0.8);"></h2>
    </div>

    <div id="info-panel" class="flex flex-col md:flex-row justify-around w-full max-w-4xl mt-5 gap-4">
        <div id="player1-info" class="w-full md:w-64 p-3 border-2 border-[#ccc] rounded-lg bg-black bg-opacity-20">
            <h3 id="p1-title">Player 1 (Human)</h3>
            <p id="player1-score">Score: 0</p>
        </div>
        <div id="player2-info" class="w-full md:w-64 p-3 border-2 border-[#ccc] rounded-lg bg-black bg-opacity-20">
            <h3 id="p2-title">Player 2 (AI)</h3>
            <p id="player2-score">Score: 0</p>
        </div>
    </div>
    <p id="game-status" class="text-lg font-bold h-12 mt-2"></p>
    <p id="game-over" class="text-xl text-[#e74c3c] font-bold"></p>
    <button id="reset-button" class="mt-4 px-5 py-2 text-lg cursor-pointer border-none rounded-md bg-[#4a69bd] text-white hover:bg-[#6a89cc]">New Game</button>
</div>

<script>
    // ===================================================================================
    // GAME ENGINE (The "Brain")
    // ===================================================================================
    class GameEngine {
        constructor() {
            this.COLS = 8;
            this.ROWS = 4;
            this.SQUARES = this.COLS * this.ROWS;
            this.scores = { 'k': 8, 'q': 17, 'r': 11, 'b': 6, 'n': 5, 'p': 4 };
            this.reset();
        }

        reset() {
            const pieces = [
                'R','N','B','Q','K','B','N','R', 'P','P','P','P','P','P','P','P',
                'r','n','b','q','k','b','n','r', 'p','p','p','p','p','p','p','p'
            ];
            
            for (let i = pieces.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [pieces[i], pieces[j]] = [pieces[j], pieces[i]];
            }

            this.board = pieces.map(p => ({ piece: p, isFlipped: false }));
            this.isGameStarted = false;
            this.isGameOver = false;
            this.humanPlayerColor = null;
            this.isWhiteTurn = true;
            this.penalties = { white: 0, black: 0 }; // **NEW**: Track penalty scores
        }

        isWhitePiece(piece) {
            return piece && piece.toUpperCase() === piece;
        }

        isPieceOfCurrentTurn(piece) {
            if (!piece) return false;
            return this.isWhiteTurn === this.isWhitePiece(piece);
        }

        handleFirstFlip(index, firstPlayerIsHuman) {
            const cell = this.board[index];
            if (!cell.piece) return null;

            cell.isFlipped = true;
            this.isGameStarted = true;

            const revealedColorIsWhite = this.isWhitePiece(cell.piece);
            
            if (firstPlayerIsHuman) {
                this.humanPlayerColor = revealedColorIsWhite ? 'white' : 'black';
            } else {
                this.humanPlayerColor = revealedColorIsWhite ? 'black' : 'white';
            }
            
            this.isWhiteTurn = revealedColorIsWhite;
            this.switchTurn();
            return { type: 'flip', from: index, to: index };
        }
        
        handleFlip(index) {
            const cell = this.board[index];
            if (cell.isFlipped) return null;
            cell.isFlipped = true;
            this.switchTurn();
            return { type: 'flip', from: index, to: index };
        }

        handleMove(from, to) {
            if (!this.getValidMoves(this.board, this.board[from].piece, from).includes(to)) {
                return null;
            }
            
            // **NEW**: Apply penalty for non-capture moves
            if (!this.board[to].piece) {
                const colorToPenalize = this.isWhiteTurn ? 'white' : 'black';
                this.penalties[colorToPenalize]--;
            }

            this.board[to] = { ...this.board[from] };
            this.board[from] = { piece: null, isFlipped: true };
            this.switchTurn();
            return { type: 'move', from, to };
        }

        switchTurn() {
            this.isWhiteTurn = !this.isWhiteTurn;
            this.checkGameOver();
        }

        checkGameOver() {
            if (!this.isGameStarted || this.humanPlayerColor === null) return;

            let hasLegalAction = false;
            if (this.board.some(cell => !cell.isFlipped)) {
                hasLegalAction = true;
            }

            if (!hasLegalAction) {
                for (let i = 0; i < this.SQUARES; i++) {
                    const cell = this.board[i];
                    if (cell.piece && this.isPieceOfCurrentTurn(cell.piece)) {
                        if (this.getValidMoves(this.board, cell.piece, i).length > 0) {
                            hasLegalAction = true;
                            break;
                        }
                    }
                }
            }
            
            if (!hasLegalAction) {
                this.isGameOver = true;
            }
        }
        
        getScores() {
            let whiteScore = 0, blackScore = 0;
            this.board.forEach(cell => {
                if(cell.isFlipped && cell.piece) {
                    const score = this.scores[cell.piece.toLowerCase()];
                    if(this.isWhitePiece(cell.piece)) whiteScore += score;
                    else blackScore += score;
                }
            });
            // **NEW**: Add penalties to the final score
            whiteScore += this.penalties.white;
            blackScore += this.penalties.black;
            return { whiteScore, blackScore };
        }

        getValidMoves(boardState, piece, index) {
            const legalMoves = [];
            const r = Math.floor(index / this.COLS);
            const c = index % this.COLS;
            const pieceIsWhite = this.isWhitePiece(piece);

            const isOnBoard = (row, col) => row >= 0 && row < this.ROWS && col >= 0 && col < this.COLS;
            const getIndex = (row, col) => row * this.COLS + col;

            switch (piece.toLowerCase()) {
                case 'p':
                    const straightMoveDirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                    const diagonalCaptureDirs = [[-1, -1], [-1, 1], [1, -1], [1, 1]];

                    straightMoveDirs.forEach(([rd, cd]) => {
                        if (isOnBoard(r + rd, c + cd)) {
                            const targetIndex = getIndex(r + rd, c + cd);
                            const targetCell = boardState[targetIndex];
                            if (targetCell.isFlipped && !targetCell.piece) {
                                legalMoves.push(targetIndex);
                            }
                        }
                    });

                    diagonalCaptureDirs.forEach(([rd, cd]) => {
                        if (isOnBoard(r + rd, c + cd)) {
                            const targetIndex = getIndex(r + rd, c + cd);
                            const targetCell = boardState[targetIndex];
                            if (targetCell.isFlipped && targetCell.piece && this.isWhitePiece(targetCell.piece) !== pieceIsWhite) {
                                legalMoves.push(targetIndex);
                            }
                        }
                    });
                    break;
                
                case 'r': case 'q': case 'b':
                    const directions = 
                        piece.toLowerCase() === 'r' ? [[-1, 0], [1, 0], [0, -1], [0, 1]] :
                        piece.toLowerCase() === 'b' ? [[-1, -1], [-1, 1], [1, -1], [1, 1]] :
                        [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]];

                    directions.forEach(([rd, cd]) => {
                        let temp_r = r + rd, temp_c = c + cd;
                        while(isOnBoard(temp_r, temp_c)){
                            const i = getIndex(temp_r, temp_c);
                            if(!boardState[i].isFlipped) break;
                            if(boardState[i].piece){
                                if(this.isWhitePiece(boardState[i].piece) !== pieceIsWhite) legalMoves.push(i);
                                break;
                            }
                            legalMoves.push(i);
                            temp_r += rd; temp_c += cd;
                        }
                    });
                    break;
                
                case 'n':
                    [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]].forEach(([rd,cd]) => {
                         if(isOnBoard(r+rd, c+cd)){
                            const targetIndex = getIndex(r+rd, c+cd);
                            const targetCell = boardState[targetIndex];
                            if(targetCell.isFlipped && (!targetCell.piece || this.isWhitePiece(targetCell.piece) !== pieceIsWhite)) {
                                legalMoves.push(targetIndex);
                            }
                        }
                    });
                    break;

                case 'k':
                    [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[-1,1],[1,-1],[1,1]].forEach(([rd,cd]) => {
                         if(isOnBoard(r+rd, c+cd)){
                            const targetIndex = getIndex(r+rd, c+cd);
                            const targetCell = boardState[targetIndex];
                            if(targetCell.isFlipped && (!targetCell.piece || this.isWhitePiece(targetCell.piece) !== pieceIsWhite)) {
                                legalMoves.push(targetIndex);
                            }
                        }
                    });
                    break;
            }
            return legalMoves;
        }
    }

    // ===================================================================================
    // AI PLAYER
    // ===================================================================================
    class AIPlayer {
        constructor(game) {
            this.game = game;
        }

        evaluateBoard(board) {
            let score = 0;
            board.forEach(cell => {
                if (cell.piece && cell.isFlipped) {
                    const pieceScore = this.game.scores[cell.piece.toLowerCase()];
                    score += this.game.isWhitePiece(cell.piece) ? pieceScore : -pieceScore;
                }
            });
            return score;
        }

        findBestMove() {
            let bestScore = -Infinity;
            let bestMove = null;
            const aiIsWhite = this.game.isWhiteTurn;

            const allPossibleMoves = [];
            for (let i = 0; i < this.game.SQUARES; i++) {
                const cell = this.game.board[i];
                if (cell.piece && cell.isFlipped && this.game.isPieceOfCurrentTurn(cell.piece)) {
                    const moves = this.game.getValidMoves(this.game.board, cell.piece, i);
                    moves.forEach(move => {
                        allPossibleMoves.push({ type: 'move', from: i, to: move });
                    });
                }
            }

            for (const move of allPossibleMoves) {
                const tempBoard = JSON.parse(JSON.stringify(this.game.board));
                tempBoard[move.to] = { ...tempBoard[move.from] };
                tempBoard[move.from] = { piece: null, isFlipped: true };
                
                let score = this.evaluateBoard(tempBoard);
                if (!aiIsWhite) score = -score;

                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                }
            }
            
            if (bestMove) {
                return bestMove;
            }

            const unflippedIndices = [];
            this.game.board.forEach((cell, index) => {
                if (!cell.isFlipped) unflippedIndices.push(index);
            });

            if (unflippedIndices.length > 0) {
                const randomFlipIndex = unflippedIndices[Math.floor(Math.random() * unflippedIndices.length)];
                return { type: 'flip', from: randomFlipIndex, to: randomFlipIndex };
            }

            return null;
        }
    }

    // ===================================================================================
    // UI CONTROLLER
    // ===================================================================================
    class GameUI {
        constructor() {
            this.game = new GameEngine();
            this.ai = new AIPlayer(this.game);
            this.boardElement = document.getElementById('chess-board');
            this.p1ScoreEl = document.getElementById('player1-score');
            this.p2ScoreEl = document.getElementById('player2-score');
            this.p1TitleEl = document.getElementById('p1-title');
            this.p2TitleEl = document.getElementById('p2-title');
            this.gameStatusEl = document.getElementById('game-status');
            this.gameOverEl = document.getElementById('game-over');
            this.resetButton = document.getElementById('reset-button');
            this.p1InfoEl = document.getElementById('player1-info');
            this.p2InfoEl = document.getElementById('player2-info');
            this.pregameOverlay = document.getElementById('pregame-overlay');
            this.humanFirstBtn = document.getElementById('human-first-btn');
            this.aiFirstBtn = document.getElementById('ai-first-btn');
            this.winnerOverlay = document.getElementById('winner-overlay');
            this.winnerText = document.getElementById('winner-text');
            
            this.selectedPieceIndex = null;
            this.validMoves = [];
            this.isTurnInProgress = false;
            this.humanGoesFirst = true;

            this.resetButton.addEventListener('click', () => this.initialize());
            this.humanFirstBtn.addEventListener('click', () => this.startGame(true));
            this.aiFirstBtn.addEventListener('click', () => this.startGame(false));
            this.winnerOverlay.addEventListener('click', () => this.initialize());
            this.initialize();
        }

        initialize() {
            this.game.reset();
            this.selectedPieceIndex = null;
            this.validMoves = [];
            this.isTurnInProgress = false;
            this.winnerOverlay.classList.add('hidden');
            this.winnerOverlay.classList.remove('flex');
            this.pregameOverlay.classList.remove('hidden');
            this.pregameOverlay.classList.add('flex');
            this.updatePlayerUI();
            this.renderBoard();
        }

        startGame(humanFirst) {
            this.humanGoesFirst = humanFirst;
            this.pregameOverlay.classList.add('hidden');
            this.pregameOverlay.classList.remove('flex');
            
            if (humanFirst) {
                this.gameStatusEl.textContent = 'Your turn: Flip a piece to begin!';
            } else {
                this.gameStatusEl.textContent = 'AI is making the first move...';
                this.isTurnInProgress = true;
                setTimeout(() => {
                    const firstFlipIndex = Math.floor(Math.random() * this.game.SQUARES);
                    this.game.handleFirstFlip(firstFlipIndex, false);
                    this.renderBoard();
                    this.updatePlayerUI();
                    this.isTurnInProgress = false;
                }, 1000);
            }
        }

        renderBoard() {
            this.boardElement.innerHTML = '';
            for (let i = 0; i < this.game.SQUARES; i++) {
                const square = document.createElement('div');
                square.className = 'square flex items-center justify-center box-border border border-[#b38b5d] cursor-pointer';
                
                const cell = this.game.board[i];
                const pieceSpan = document.createElement('span');
                pieceSpan.className = 'piece w-[60px] h-[60px] rounded-full flex items-center justify-center text-4xl font-bold shadow-md';

                if (!cell.isFlipped) {
                    pieceSpan.classList.add('hidden-piece', 'bg-[#4a779c]', 'border-2', 'border-[#2e4a60]');
                    pieceSpan.innerHTML = '&#9733;';
                } else if (cell.piece) {
                    const pieceColorClass = this.game.isWhitePiece(cell.piece) ? 'red-piece' : 'blue-piece';
                    pieceSpan.classList.add(pieceColorClass, 'bg-[#f0d9b5]');
                    pieceSpan.textContent = this.getPieceUnicode(cell.piece);
                }
                square.appendChild(pieceSpan);

                if (this.selectedPieceIndex === i) {
                    square.classList.add('bg-[#55a630!important]', 'border-2', 'border-[#386641]');
                }
                if (this.validMoves.includes(i)) {
                    square.classList.add('valid-move');
                }

                square.addEventListener('click', () => this.onSquareClick(i));
                this.boardElement.appendChild(square);
            }
        }

        onSquareClick(index) {
            if (this.game.isGameOver || this.isTurnInProgress) return;
            
            if (this.game.isGameStarted && !this.isHumanTurnNow()) return;

            if (!this.game.isGameStarted) {
                this.isTurnInProgress = true;
                this.game.handleFirstFlip(index, this.humanGoesFirst);
                this.renderBoard();
                setTimeout(() => {
                    this.isTurnInProgress = false;
                    this.updatePlayerUI();
                    this.checkForAITurn();
                }, 500);
                return;
            }

            const clickedCell = this.game.board[index];

            if (this.selectedPieceIndex !== null) {
                if (this.validMoves.includes(index)) {
                    this.game.handleMove(this.selectedPieceIndex, index);
                    this.selectedPieceIndex = null;
                    this.validMoves = [];
                    this.updatePlayerUI();
                    this.renderBoard();
                    this.checkForAITurn();
                } else {
                    this.selectedPieceIndex = null;
                    this.validMoves = [];
                    this.renderBoard();
                }
                return;
            }
            
            if (!clickedCell.isFlipped) {
                this.isTurnInProgress = true;
                this.game.handleFlip(index);
                this.renderBoard();
                setTimeout(() => {
                    this.isTurnInProgress = false;
                    this.updatePlayerUI();
                    this.checkForAITurn();
                }, 500);
                return;
            }

            if (clickedCell.piece && this.game.isPieceOfCurrentTurn(clickedCell.piece)) {
                this.selectedPieceIndex = index;
                this.validMoves = this.game.getValidMoves(this.game.board, clickedCell.piece, index);
                this.renderBoard();
            }
        }
        
        isHumanTurnNow() {
            if (!this.game.isGameStarted) return this.humanGoesFirst;
            return this.game.isWhitePiece(this.game.humanPlayerColor) === this.game.isWhiteTurn;
        }

        checkForAITurn() {
            if (this.game.isGameOver) return;
            
            if (!this.isHumanTurnNow()) {
                this.isTurnInProgress = true;
                this.gameStatusEl.textContent = "AI is thinking...";
                setTimeout(() => {
                    const move = this.ai.findBestMove();
                    if (move) {
                        if (move.type === 'flip') {
                            this.game.handleFlip(move.from);
                        } else {
                            this.game.handleMove(move.from, move.to);
                        }
                    } else {
                        this.game.checkGameOver();
                    }
                    this.updatePlayerUI();
                    this.renderBoard();
                    this.isTurnInProgress = false;
                }, 1000); 
            }
        }

        updatePlayerUI() {
            const currentTurnColor = this.game.isWhiteTurn ? 'Red' : 'Blue';
            const flippedCount = this.game.board.filter(c => c.isFlipped).length;
            this.gameStatusEl.innerHTML = `${currentTurnColor}'s Turn <br> (Flipped: ${flippedCount} / 32)`;
             
            if (this.game.humanPlayerColor) {
                const humanDisplayColor = this.game.humanPlayerColor === 'white' ? 'Red' : 'Blue';
                const aiDisplayColor = this.game.humanPlayerColor === 'white' ? 'Blue' : 'Red';
                
                this.p1TitleEl.innerHTML = `Human (<span class="${humanDisplayColor === 'Red' ? 'text-red-500' : 'text-blue-500'}">${humanDisplayColor}</span>)`;
                this.p2TitleEl.innerHTML = `AI (<span class="${aiDisplayColor === 'Red' ? 'text-red-500' : 'text-blue-500'}">${aiDisplayColor}</span>)`;
                
            } else {
                 this.p1TitleEl.textContent = 'Player 1 (Human)';
                 this.p2TitleEl.textContent = 'Player 2 (AI)';
            }

            const scores = this.game.getScores();
            const humanIsWhite = this.game.humanPlayerColor === 'white';
            this.p1ScoreEl.textContent = `Score: ${humanIsWhite ? scores.whiteScore : scores.blackScore}`;
            this.p2ScoreEl.textContent = `Score: ${humanIsWhite ? scores.blackScore : scores.whiteScore}`;

            const isHumanTurn = this.isHumanTurnNow();
            this.p1InfoEl.classList.toggle('active', isHumanTurn);
            this.p2InfoEl.classList.toggle('active', !isHumanTurn);
            
            if (this.game.isGameOver) {
                const finalScores = this.game.getScores();
                const humanFinalScore = this.game.humanPlayerColor === 'white' ? finalScores.whiteScore : finalScores.blackScore;
                const aiFinalScore = this.game.humanPlayerColor === 'white' ? finalScores.blackScore : finalScores.whiteScore;
                
                let winnerMessage = '';
                if (humanFinalScore > aiFinalScore) winnerMessage = "You Win!";
                else if (aiFinalScore > humanFinalScore) winnerMessage = "AI Wins!";
                else winnerMessage = "It's a Draw!";
                
                this.winnerText.innerHTML = `${winnerMessage}<br><span class="text-2xl mt-4 font-normal">(Click to play again)</span>`;
                this.winnerOverlay.classList.remove('hidden');
                this.winnerOverlay.classList.add('flex');
                
                this.gameOverEl.textContent = `Game Over! Final scores are calculated.`;
                this.gameStatusEl.textContent = '';
            } else {
                this.gameOverEl.textContent = '';
            }
        }

        getPieceUnicode(piece) {
            const pieces = {
                'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',
                'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟︎'
            };
            return pieces[piece] || '';
        }
    }

    new GameUI();
</script>
</body>
</html>
